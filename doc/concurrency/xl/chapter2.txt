缓存一致性协议：为了提高数据访问效率，CPU并不直接与内存交互，而是与CPU中的高速缓存交互。所以数据被修改时，一般都是修改缓存，
               并不直接写到内存中去。这样就造成了缓存中的数据与内存中的不一致。如果系统中只有一个CPU，所有线程看到的都是缓
               存中的最新数据，当然没问题。但如果系统中有多个CPU，同一份内存可能会被缓存到多个CPU中，如果在不同CPU中运行的
               不同线程看到同一份内存的缓存值不一样就麻烦了，因此有必要维护这多种缓存的一致性。当然要做到这一点只要一有修改
               操作，就通知所有CPU更新缓存，或者放弃缓存下次访问的时候再重新从内存中读取。为解决这一问题，产生了很多维护缓存
               一致性的协议，MESI就是其中一种。

MESI：MESI协议的名称由来是指这一协议为缓存的每个数据单位（称为cache line，在Intel CPU上一般是64字节）维护两个状态位，使得每
     个数据单位可能处于M、E、S或I这四种状态之一。各种状态含义如下：
        M: 被修改（Modified)。该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的
           内存需要在未来的某个时间点（允许其它CPU读取主存中相应内存之前）写回（write back）主存。当被写回主存之后，该缓存
           行的状态会变成独享（exclusive)状态。
        E: 独享的（Exclusive)。该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何
           时刻当有其它CPU读取该内存时变成共享状态（shared)。同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。
        S: 共享的（Shared)。该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修
           改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。
        I: 无效的（Invalid）。本CPU中的这份缓存已经无效了

     当CPU要读取数据时，只要缓存的状态不是I都可以从缓存中读，否则就要从主存中读。这一读操作可能会被某个处于M或E状态的CPU截获，
     该CPU将修改的数据写出到内存，并将自己设为S状态后这一读操作才继续进行。只有缓存状态是E或M时，CPU才可以修改其中的数据，修改
     后缓存即处于M状态。如果CPU要修改数据时发现其缓存不处于E或M状态，则需要发出特殊的RFO指令（Read For Ownership），将其它CPU的缓存设为I状态。


自旋：当发生争用时，若Owner线程能在很短的时间内释放锁，则那些正在争用线程可以稍微等一等（自旋），在Owner线程释放锁后，争用线程可能会立即得到锁，
     从而避免了系统阻塞。但Owner运行的时间可能会超出了临界值，争用线程自旋一段时间后还是无法获得锁，这时争用线程则会停止自旋进入阻塞状态（后退）。
     基本思路就是自旋，不成功再阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有非常重要的性能提高。自旋锁有个更贴切的名字：自旋-指数
     后退锁，也即复合锁。
     线程自旋的时候其实啥都不做，可以执行几次for循环，可以执行几条空的汇编指令，目的是占着CPU不放，等待获取锁的机会。

Monitor：参考http://www.importnew.com/18176.html

=======================================分割线，以上名词书中多次提到，但未详细解释，补充一下（搬运工）============================================


volatile：如果一个变量被声明为volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。CPU在处理volatile修饰的变量时，会加一个Lock前缀的指令。
          Lock前缀的指令在多核处理器下会引发两件事情：
          1）、将当前处理器的缓存行数据写会到系统内存（主内存）。
          2）、这个写回到内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

volatile实现原则：
         1）、Lock前缀指令会引发处理器缓存回写到内存
         2）、一个处理器的缓存回写到内存会导致其他处理器的缓存无效。使用MESI协议维护缓存一致性

synchronize：
         1）、用于修饰普通方法，锁是当前示例对象；
         2）、用于修饰静态方法，锁是当前类的Class对象；
         3）、用于修饰方法块，锁是synchronize括号里配置的对象。

synchronize实现原理：JVM基于进入和退出Monitor来实现方法同步和代码快同步，具体实现细节不一样。
                    代码块同步是使用monitorenter和monitorexit实现。monitorenter在编译后插入到同步代码块开始位置，
                    monitorexit在编译后插入到同步代码结束位置和异常处。每个monitorenter必须有monitorexit与之匹配。

Java对象头：对象头信息是与对象自身定义的数据无关的额外存储成本。
           数组类型，3个字宽存储对象头；非数组类型，2字宽存储对象头。32位虚拟机中，1字宽=4字节

32位JVM Mark Word存储结构：
    锁状态      |       25bit        |       4bit       |     1bit是否是偏向锁     |     2bit锁标志位
-----------------------------------------------------------------------------------------------------
   无锁状态     |    对象的hashCode   |   对象分代年龄    |            0            |          01


HotSpot虚拟机对象头Mark Word
        存储内容                |       1bit是否是偏向锁      |       2bit锁标志位         |        状态
------------------------------------------------------------------------------------------------------
    对象哈希码、分代年龄                         0                       01                         未锁定
    指向锁记录的指针                                                    00                          轻量级锁定
    指向重量级锁的指针                                                   10                          膨胀（重量级锁定）
    空，不需要记录信息                                                   11                          GC标记
偏向线程ID、偏向时间戳、对象分代年龄               1                      01                          可偏向

锁的升级：Java SE1.6中，锁一共有四种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。这几个
         状态可以随着竞争升级，但不能降级

偏向锁：在无竞争情况下，锁会偏向于第一个获得该锁的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的
       线程将永远不需要在进行同步。Java 6 和Java 7默认启用偏向锁。
       参数-XX:UseBiasedLocking=false，关闭偏向锁，程序默认进入轻量级锁状态
       参数-XX:BiasedLockingStartupDelay=0，关闭延迟（Java 6和7默认延迟的）


偏向锁撤销：当有另外一个线程去尝试获取还这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向恢复到
           未锁定（标志位为"01"）或轻量级锁定（标志位为"00"）的状态。


轻量级锁：
    1）、轻量级锁加锁
         先创建存储锁记录的空间，将对象头中的Mark Word复制到锁记录中，尝试使用CAS替换Mark Word指向锁记录，成功获取锁；失败，自旋
    2）、轻量级锁解锁
         将锁记录使用CAS操作替换回到对象头，成功，没有竞争；失败，存在竞争，膨胀为重量级锁。

锁的对比：
    锁                           优点                                              缺点                                  适用场景
  偏向锁             加锁和解锁不需要额外的消耗，和执行非同步          如果线程存在锁竞争，会带来额外的锁               适用于只有一个线程访问同步块
                    方法相比仅存在纳秒级别的差距                      撤销的消耗
轻量级锁             竞争的线程不会阻塞，提高了程序的响应速度          如果始终得不到锁竞争的线程使用自旋会消耗CPU      追求响应时间，同步块执行非常快
重量级锁             线程竞争不使自旋，不会消耗CPU                    线程阻塞，响应时间缓慢                         追求吞吐量，同步快执行速度较长


原子操作
    概念：不可被中断的一个或一系列操作。
    实现原理：
        1、处理器上实现原子操作
            1）、使用总线锁保证原子性。处理器提供一个Lock#信号在总线上输出，其他处理器对共享内存的请求将被阻塞，该处理器独占共享内存。锁定总线，其他处理器对其他内存地址的访问被阻塞，开销大
            2）、使用缓存锁保证原子性。锁定处理器内部缓存，通过缓存一致性机制保证操作原子性，当其他CPU修改已被锁定的缓存行数据时，会使该缓存行无效。
        2、Java实现原子操作
            使用循环CAS实现原子操作。自旋CAS实现的基本思路就是循环进行CAS操作，直到成功为止。
            CAS缺点：
            1）、ABA问题。如果一个变量值是A，变成B，随后又变成了A，CAS会认为值没有发生变化，但实际缺发生变化了。解决办法，给变量加上版本号：
                 A——>B——>A变成1A——>2B——3A
            2）、循环时间长开销大
            3）、只能保证一个共享变量的原子操作
        3、使用锁机制实现原子操作
            锁机制保证只有获得锁的线程才能够操作锁定的内存区域。




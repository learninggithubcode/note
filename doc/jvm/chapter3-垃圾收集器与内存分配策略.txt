判断对象是否已死

    引用计数算法

    可达性分析算法 （java）：当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
        GC Roots：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、Native引用的对象。
        引用链

    引用
        强引用
        软引用
        弱引用
        虚引用

    生存和死亡
        对象被回收至少经历两次过程。

    回收方法区
        废弃常量
        无用类

垃圾收集算法

    标记-清除算法
        先标记后清除，效率低下

    复制算法
        原理：将内存分为n快并分为2组，其中一组专门用作GC处理，每次GC处理后，将还存活着的对象复制到另一组内存中。同时需要分配担保支持。
        解决效率问题，代价是将内存缩小了。

    标记-整理算法

    分代收集算法 ***（当前商业虚拟机采用）
        根据对象的存活周期的不同将内存划分几块，一般是把java堆划分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，那就选用
        复制算法，而老年代存活率高，就使用“标记-清楚”或“标记-整理”算法来进行回收。

HotSpot的算法实现

    枚举根节点
        准确式GC,OopMap（主流）

    安全点
        有生成OopMap的指令处
        GC是线程需要停止等待的地方

    安全区域
        一段代码片段之间，引用关系不会发生变化

垃圾收集器
    内存回收的具体实现
    linux查看当前使用的垃圾收集器：jmap -heap PID

    Serial收集器
        新生代收集器
        复制算法
        单线程
        进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束
        新生代采用复制算法
        常用于桌面应用

    ParNew收集器
        新生代收集器
        复制算法
        Serial收集器多线程版本，其余特性与Serial收集器一样
        Server模式下的虚拟机中首选的新生代收集器
        能与CMS收集器配合工作

    Parallel Scavenge收集器
        新生代收集器
        复制算法
        多线程、并行
        吞吐量优先
        自适应调节策略

    Serial Old收集器
        单线程
        采用标记-整理算法

    Parallel Old收集器
        多线程、并行
        采用标记-整理算法

    CMS收集器 （Concurrent Mark-Sweep）  ***
        并发收集、低停顿
        一种以获取最短回收停顿时间为目标的收集器
        适用于重视响应速度的应用
        采用“标记-清除”
        步骤：
            初始标记：需要 "stop the world" ，标记一下GC Roots 能直接关联到的对象
            并发标记：与用户线程同步，GC RootsTracing 的过程
            重新标记：需要 "stop the world" ，修正标记记录
            并发清除：与用户线程同步，
        缺点：
            无法处理浮动垃圾（并发是用户线程产生的新垃圾）
            可能出现因“预留空间”不足引发“Concurrent Mode Failure”失败而导致另一次Full GC
        涉及参数：
            -XX:CMSInitiatingOccupancyFraction=70 设置阀值为70%，默认为68%。
            -XX:+UseCMSCompactAtFullCollection 表示CMS顶不住要进行FGC时开启内存碎片合并整理过程，默认就是开启的。
            -XX:CMSFullGCsBeforeCompaction=1 设置多少次full gc后进行内存压缩（前提UseCMSCompactAtFullCollection已经开启），由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生"碎片"。

    G1收集器
        当今收集器技术发展的最前沿成果之一

理解GC日志


垃圾收集器参数总结
    参考：http://www.360doc.cn/article/2159920_68484779.html
    -XX:+UseSerialGC  	虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收
    -XX:+UseParNewGC    打开此开关后，使用ParNew + Serial Old的收集器进行垃圾回收
    -XX:+UseConcMarkSweepGC   使用ParNew + CMS +  Serial Old的收集器组合进行内存回收，Serial Old作为CMS出现“Concurrent Mode Failure”失败后的后备收集器使用
    -XX:+UseParallelGC    	虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge +  Serial Old的收集器组合进行回收
    -XX:+UseParallelOldGC   使用Parallel Scavenge +  Parallel Old的收集器组合进行回收
    -XX:SurvivorRatio   新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Subrvivor = 8:1
    -XX:PretenureSizeThreshold  直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配
    -XX:MaxTenuringThreshold   晋升到老年代的对象年龄，每次Minor GC之后，年龄就加1，当超过这个参数的值时进入老年代
    -XX:UseAdaptiveSizePolicy   动态调整java堆中各个区域的大小以及进入老年代的年龄
    -XX:+HandlePromotionFailure   是否允许新生代收集担保，进行一次minor gc后, 另一块Survivor空间不足时，将直接会在老年代中保留
    -XX:ParallelGCThreads   	设置并行GC进行内存回收的线程数
    -XX:GCTimeRatio    GC时间占总时间的比列，默认值为99，即允许1%的GC时间，仅在使用Parallel Scavenge 收集器时有效
    -XX:MaxGCPauseMillis   	设置GC的最大停顿时间，在Parallel Scavenge 收集器下有效
    -XX:CMSInitiatingOccupancyFraction  设置CMS收集器在老年代空间被使用多少后出发垃圾收集，默认值为68%，仅在CMS收集器时有效，-XX:CMSInitiatingOccupancyFraction=70
    -XX:+UseCMSCompactAtFullCollection    由于CMS收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在CMS收集器时有效
    -XX:+CMSFullGCBeforeCompaction   设置CMS收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，前提是UseCMSCompactAtFullCollection已经开启

内存分配与回收策略

    对象的分配：对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲（解决多线程下同步分配冲突问题的一种解决方案），将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，
    具体规则还是由使用的垃圾收集器和内存相关的参数的设置决定。

    对象优先在Eden分配


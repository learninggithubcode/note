参考：http://swiftlet.net/archives/1964
泛型的起源:

    第一阶段：在类和方法中，人们只能使用具体的类型：要么是基本类型，要么是自定义的类。这一阶段，程序的通用性很差。

    第二阶段：在面向对象编程语言中，使用多态机制。例如，可以将方法的参数类型设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数。
            这样的方法更加通用一些，可应用的地方也多一些。但是，需要注意的是final类不能扩展。

    第三阶段：有时候，拘泥于单继承体系，也会使程序受限太多。如果方法的参数是一个接口而不是一个类，这种限制就放松了很多。因为任何实现了该接口的类都满足该方法。
            这个阶段，使用了面向接口的编程思想，让程序的通用性更强大了。

    第四阶段：有时候，即使是使用了接口，对程序的约束也还是太强了，因为一旦指明了接口，它就要求你的代码必须使用特定的接口。而我们希望达到的目的是编写更通用的代码，
            要是代码应用于“某种不具体的类型”，而不是一个具体的接口或者类。这种“不具体的类型”，属于参数化类型，也就是说：把类型当做参数。
            当定义的时候，我们把类型当做一个参数；在使用的时候，我们才将这个参数用具体的类型来代替。为了实现参数化类型的目标，从而出现了泛型的机制。

泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。

泛型的目的：
    用来指定容器要持有什么类型的对象、而且由编译器来保证类型的正确性。

元组：它是将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中的元素，但是不允许向其中存放新的对象。

泛型的用武之处:


泛型的语法标示:

泛型的种类：
    泛型方法：http://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html


<?>和<Object>的区别：

协变和逆变：

< ? extends E >和< ? super E > 背后的思想：容器的分类：

泛型实例化：

